# 1. Standard Reverse a String Task (HackerRank/LeetCode Style)

## Task Description

Given a string s, return the string reversed.

### Example

```bash
Input:
hello
```

```bash 
Output:

olleh
```

# 2. Variant Tasks (More Like Real Coding Interview Platforms)

## Task A — Reverse Characters Only

Reverse the characters of the string but ignore whitespace positions.

```bash
Input: "a b c"
Output: "c b a"
```

## Task B — Reverse Words in a Sentence

Reverse the order of words in a string.

```bash
Input:

the sky is blue
```


```bash
Output:

blue is sky the
```

## Task C — Reverse a String In-Place (Array of chars)

You are given a character array. Reverse it without returning a new array (modify in-place).

## Task D — Reverse Only Letters

Keep digits and special characters in place, but reverse alphabetical characters.

Input: "a-bC-dEf-ghIj"
Output: "j-Ih-gfE-dCba"

## Task E — Recursive Reverse

Reverse using a recursive function.

# Java Solutions
## Standard Revers a String 

```java
public class ReverseStringSolution {

    public static String reverseString(String s){
        return new StringBuilder(s).reverse().toString();
    }

    public static void main(String [] args){
        System.out.println(reverseString("hello"));
    }
}
```

What kind of “reverse” is this?
1. In-place byte-level reversal

The code takes the internal byte[] value and swaps:
```java
val[0] with val[n]

val[1] with val[n-1]
```
… until it reaches the middle.

This avoids creating a new array → faster and more memory-efficient.
```java
for (int j = (n-1) >> 1; j >= 0; j--) {
    int k = n - j;
    byte cj = val[j];
    val[j] = val[k];
    val[k] = cj;
}
```

This is a classical two-pointer swap reverse algorithm.


| Aspect            | What it does                         |
| ----------------- | ------------------------------------ |
| Algorithm         | Two-pointer in-place reversal        |
| Memory usage      | No new array → efficient             |
| Encoding          | Handles LATIN1 and UTF-16 separately |
| Surrogate pairs   | UTF-16 branch preserves them         |
| Grapheme clusters |  Not preserved                      |
| Complexity        | O(n) time, O(1) extra space          |

## Task A — Reverse Characters Only (Ignore Spaces)


```java
public class ReverseCharactersOnly{

    public static String reverseIgnoreSpace(String s){
        char [] arr = s.toCharArray();
        int left = 0, right = arr.length -1;

        while (left < right) {
            if (arr[left] == ' ') {
                left++;
            } else if (arr[right] == ' ') {
                right--;
            } else {
                char temp = arr[left];
                arr[left]  = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
        return new String(arr);
    }

    public static void main(String[] args){
        System.out.println(reverseIgnoreSpace("a b c"));
    }
}

```

## Task B — Reverse Words in a Sentence

```java

import java.util.*;
import java.util.Arrays.*;

public class ReverseWordsInSentence {

    public static String reverseWords(String s){
        String[] words = s.trim().split("\\s+");
        Collections.reverse(Arrays.asList(words));
        return String.join(" ", words);

    }

    public static void main(String[] args){

        System.out.println(reverseWords("The sky is blue, the river is red"));
    }
}

```

## Task C — Reverse a Char Array In-Place

```java
  public class ReverseCharArrayInPlace{
    public static void reverseCharArray(char[] s){
        int left =0, right = s.length -1;

        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;

            left++;
            right--;

        }
    }

    public static void main(String[] args){
        char[] arr = {'h','e','l','l','o'};
        reverseCharArray(arr);
        System.out.println(arr);

    }
}
```

## Task D — Reverse Only Letters

```java

public class ReverOnlyLetters{
    public static String reverseOnlyLetters(String s){
        char[] arr = s.toCharArray();
        int left = 0, right = arr.length -1;

        while (left < right){
            if(!Character.isLetter(arr[left])){
                left++;
            } else if (!Character.isLetter(arr[right])){
                right--;
            } else {
                char temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
        return new String(arr);
    }

    public static void main(String[] args){
        System.out.println(reverseOnlyLetters("a-bC-dEf-ghIj"));
    }
}

```

## Task E — Recursive Reverse

```java
public class RecursiveReverse{

    public static String reverseRecursively(String s){
        if(s.isEmpty()) return s;
        return reverseRecursively(s.substring(1) + s.charAt(0));
    }

    public static void main(String[] args){
        System.out.println(reverseRecursively("hello"));
    }
}
```